{
  "adjust": {
    "count": 1,
    "reason": "accepts an array-like object"
  },
  "allPass": {
    "count": 1,
    "reason": "returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "anyPass": {
    "count": 1,
    "reason": "returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "both": {
    "count": 1,
    "reason": "accepts fantasy-land applicative functors"
  },
  "either": {
    "count": 1,
    "reason": "accepts fantasy-land applicative functors"
  },
  "complement": {
    "count": 1,
    "reason": "accepts fantasy-land applicative functors"
  },
  "difference": {
    "count": 1,
    "reason": "Negative zero"
  },
  "compose": {
    "count": 3,
    "reasons": "passes context to functions|composed functions have no length"
  },
  "curry": {
    "count": 5,
    "reason": "passes context to functions"
  },
  "concat": {
    "count": 1,
    "reason": "pass to concat method if present"
  },
  "dropLast": {
    "count": 5,
    "reason": "can act as a transducer"
  },
  "clone": {
    "count": 9,
    "reason": "Rambda work only with objects and arrays"
  },
  "endsWith": {
    "count": 4,
    "reason": "Rambda doesn't support arrays"
  },
  "equals": {
    "count": 14,
    "reason": "Rambda doesn't support regex, recursive data structures, objects with same enumerable properties, map/weakmap type of variables, dispatches to `equals` method recursively"
  },
  "filter": {
    "count": 1,
    "reason": "dispatches to `filter` method of object"
  },
  "flip": {
    "count": 4,
    "reason": "Rambda flip work for functions with two arguments"
  },
  "forEach": {
    "count": 1,
    "reason": "dispatches to `forEach` method"
  },
  "groupBy": {
    "count": 1,
    "reason": "dispatches on transformer objects in list position"
  },
  "has": {
    "count": 1,
    "reason": "Rambda does check properties from the prototype chain"
  },
  "ifElse": {
    "count": 2,
    "reason": "returns a curried function"
  },
  "includes": {
    "count": 1,
    "reason": "pass to equals method if available"
  },
  "indexBy": {
    "count": 1,
    "reason": "can act as a transducer"
  },
  "indexOf": {
    "count": 2,
    "reason": "dispatches to `indexOf` method"
  },
  "lastIndexOf": {
    "count": 3,
    "reason": "dispatches to `lastIndexOf` method"
  },
  "length": {
    "count": 1,
    "reason": "object with `length` method"
  },
  "keys": {
    "count": 1,
    "reason": "works for primitives"
  },
  "path": {
    "count": 1,
    "reason": "takes a path that contains negative indices into arrays"
  },
  "trim": {
    "count": 1,
    "reason":"trims all ES5 whitespace"
  },
  "type": {
    "count": 1,
    "reason": "Ramda returns 'Number' type to NaN input"
  },
  "uniq": {
    "count": 2,
    "reason": "pass to `uniq` method|uses reference equality for functions"
  },
  "update": {
    "count": 1,
    "reason": "accepts an array-like object"
  },
  "without": {
    "count": 2,
    "reason": "act as a transducer|pass to equals method"
  },
  "startsWith": {
    "count": 1,
    "reason": "Rambda doesn't support arrays"
  }
}